# exengine (Marcin Krzyzanowski)
simplistic exchange engine

# build
```
git clone --recursive git@github.com:mkrzyzan/exengine.git
mkmdir build;
cd build
cmake ../exengine/
make
make test
```

# architecture
[Diagram](https://www.draw.io/?lightbox=1&highlight=0000ff&edit=_blank&layers=1&nav=1&title=exchangeFlow.drawio#R7Vpdc6M2FP01zLQPyRjJYPtxnXj7nbaTzHS3bwpcgxpZYmQR2%2Fn1K0AYsDD2JuzantQPHt0rCaR7zzkSCAffLNY%2FSZLEf4gQmIMG4drBtw5CoxHW%2F5ljUziGE79wRJKGhcutHPf0BYxzYLwpDWHZaKiEYIomTWcgOIdANXxESrFqNpsL1rxrQiKwHPcBYbb3HxqquPCO0ajy%2Fww0iss7u%2F6kqFmQsrGZyTImoVjVXHjm4BsphCpKi%2FUNsCx2ZVyKfh%2F31G4HJoGrYzrc3b68%2FAJ3T7%2FxP6%2FSX%2Bm%2Fs9EdXJXzeCYsNTM2o1WbMgRSpDyE7Cqug6ermCq4T0iQ1a50zrUvVgtmqs3lQCpY7x2ou52%2Bhg2IBSi50U3KDmMTsU0JBWOvqgQg3%2FjievDLhsQkPdpeu4qLLpjQfEWYhlaUknQZ%2FwDPeko%2FWgGDUEPImEKqWESCEzarvNMqpANtVW1%2BFyIxgfwPlNoYPpBUibYwZzfqDrIel0hlAB1zK1lFZASqCyrtSZPAiKLPzXH0ngDXSsCMR5SDg3ymBz19lLoUZaWHWAIJHYRdu%2B7k0EaDHWgjG9qjFmT73wrYrmvF5DB6X4FXWFP1qVb%2BnEH%2F2jPW7dowITc2pcH1DD%2FVjVqvzKy65VbZL0jl8zanPRIFHUmU0UmJ8nVSpaGsmpmSsKQv5DFvkEUzEZSrfJTe1PFutYcwGnHtCPQVQWpHRgmql8wPpmJBwzAHCiOPwKYkeIpyot0IJmR%2BXzzPf12kMgu6GUm1jNYz1wHpvRQcXLvDEvWGhaW6HJ0hc%2FG%2FstDUmoj5fKmRsZvC7RjekFV7VT5M0wYPzpyzJ6Cpd1Ka4v8T2ndC8UkT6r173d0T%2F63uIh%2BPL0x3kZXUO6HonILs2HiiM9x4Yv%2FwxnP8PTeeLc%2BZ5ymAPQrZW1ecHfiXr1jcndR6OzkrhNP06p8jtvA9SBJSHj0IwTpoMjxDmngInxlNhhdCkzPYJ%2BAj9wnu5JQbBeS3bxSEDEG%2Bi41Cgem9HLwaXA%2FHvt%2Fk4fjcdwr4lSroXYAKopYXsN9XBV%2FzluqdquDoMlRwz%2BPSO1LBbg5mKjjyJg0eXrn%2BucugfZx0nAziC5DB4alVcGAF937Dg1gKrjVMR3Hwdwq65nRSWcnj51rNIams1HHbq0MqgZenxL62lkqKp%2B3JLC7qP2TnvtrkgkPh%2BUizUPctte7kWK19o9TmXfWsyKbWwCje%2FudC1HwuxO7O%2BfBO%2B3wvsr%2B9LhQj6PfF9sTCtI1fxmiyhMOcJ8uk%2BARgTtcZnPsQAevpukUFUIsKoG%2BmAmMrYrN1EBMe2cy3l82CL%2BUKZwgy1%2BzYcR2%2FeLblpHm83UMW3EkzC2M7CcN%2BkqDN6pOMAuXVdy149gU%3D)

The Exengine project comprises several components:
1. Engine - keeps order books of various instruments and provide a method for adding order into order books. Adding a new order causes Engine generates internal events which are dispatched to Notifier.
2. Notifier - classifies internal events from Engine and dispatch them to TradingTools. Notifier provides a method for registering a new client by its id.
3. Exchange - a wrapper of Engine and Notifier.
4. TradingTool - simulates a trader behaviour. TradingTool receives only events designed for it (by id - Notifier takes care of that), and processes them in a loop. TradingTool has two callback functions ```algo``` and ```init``` to customise its behaviour. TradingTool can send new orders into Engine.

Auxiliary components:
1. SingleProducerSingleConsumerQueue - Light and robust lockless (but still threadsafe) queue to be shared by only two different threads.
2. MultipleProducerMultipleConsumerQueue - Queue threadsafe by mutex (system's futex). Can be shared by a number of different threads. Used as a gateway to the Exchange here. TradingTool can acquire access to it and push their orders into Exchange.
3. Threadable - class which provides an interface for spawning threads. Used by TradingTool, Exchange and Notifier.

## Engine 
Defined in file ```exchange.h``` and ```exchange.cpp```
The main purpose of the Engine is processing comming orders. It pops the new coming order from the ```<MultiProducerMultiConsumerQueue<InputOrder> q;``` and takes it for processing. it is done in ```Engine::run()``` method. New order consists of the following data: 
```
struct InputOrder 
{
  char instrument;
  uint16_t trader;
  uint16_t qty;
  Side side;
 }
 ```
 Next, the order is taken by ```PlaceOrder``` method and matched against the appropriate order book. This process generates several types of Events:
1. ```OrderPlaced``` - indicates that order been placed into order book and is still opened.
2. ```Exec``` - means that order has been fully matched with some opposite order.
3. ```Tick``` - contains an outstanding quantity of orders being not fully matched in order book.  An outstanding quantity reflects the actual quantity in orderbook.  Some orders can be partially executed, but still in open state, since only the fully executed orders are considered as closed. Tick event can be used to implement the market data. (Not implement here)

Several possible patterns of events generated by the matching engine:
1. OrderPlaced, Tick
2. Exec, OrderPlaced, Tick
3. Exec, Exec, ..., OrderPlaced, Tick
4. Exec, Tick
5. Exec, Exec, ... , Tick

Every update of the order book, generates a Tick event.

```
struct Event 
{
  EventType type;
  char instrument;
  uint16_t trader;
  uint32_t qty;
  Side side;
}
```
```trader``` - the trader id for whom the order belongs. Notifier uses it to find the client to notify. For the Tick event, trader = 0.
```qty``` - For OrderPlaced,Exec the quantity of the order placed, executed. For Tick, the outstanding quantity in order book.

## Notifier
Defined in file ```exchange.h``` and ```exchange.cpp```.
Notifier takes the events been generated by Engine and Processes them sequentially in method ```Notifier::run()```.  ```Event``` contains field ```trader``` which is the trader id. Notifier uses the number to find the client connection and resend the event to the appropriate client. Other clients don't get notified which means that architecture remains a dark pool. Unless the market data part would have been implemented.
Before Notifier starts event processing, the client has to register itself at the Notifier by method ```Notifier::registerClient(...)```.

## Exchange
Defined in file ```exchange.h``` and ```exchange.cpp```. 
Contains Engine and Notifier. Since there is no any sense for Engine and Notifier exist separately, Exchange structure glues them together in one place. Exchange also provides the methods ```Exchange::start()```,```Exchange::stop()``` to start and stop Engine and Notifier threads respectively. 

## TradingTool
Defined in file ```tradingtool.h``` and ```tradingtool.cpp```. 

## Auxiliary components:
### SingleProducerSingleConsumer 
Defined in file ```connectors.h```. Uses ring buffer to pass messages from one thread to another. The size of the ring buffer can be adjusted by the template parameter, the default ring buffer size if 64k items.
It uses atomic operations for updating the position of Producer and Consumer. I used a weak order memory model, which could be especially beneficial when compiled for INTEL architectures like SandyBridge, IvyBridge, Haswell and Broadwell cause they can perform micro-operations out of order. I did some tests on SandyBridge where this lockless queue outperformed the regular mutex synchronized queue almost 10 times. More tests are needed.
Weak order memory model:
```
  size_t current_tail = tail.load(memory_order_relaxed);
  if (current_tail == head.load(memory_order_acquire)) return false;

  x = buffer[current_tail % SIZE];
  tail.store(current_tail+1, memory_order_release);
  return true;
```
### MultiProducerMultiConsumer
Defined in file ```connectors.h```. Regular mutex synchronized queue

# Testing
There are three different types of tests defined in ```testsuite.cpp```.
1. Unittests (one compnent): ```MatchingEngineTest```
```./testsuite --gtest_filter=MatchingEngineTest*```
2. Performace: ```MultiProducerMultiConsumerQueueTest```, ```MultiProducerMultiConsumerQueueTest```
```./testsuite --gtest_filter=Multi*:Single*```
3. integration tests (all components put together, simulate real system): ```IntegrationTest ```
```./testsuite --gtest_filter=Integration*```

Google test framework has been used in this project.
For running tests, I suggest run the ```MatchingEngineTest``` and later try to play with the Performance and IntegrationTests since they can need to be tuned a little bit.
